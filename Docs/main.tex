\documentclass[a4paper, 10pt]{article}

% Use packages here
\usepackage[a4paper, left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry}
\usepackage{blindtext} % This package is used for testing
\usepackage[british]{babel} % This package is used for localisation
\usepackage{paralist} % This package creates compact lists
\usepackage{multicol} % This package arranges contents in columns
\usepackage{indentfirst} % This package is used for indentation in paragraphs
\usepackage{array}
\usepackage{amsmath} % This package is used for conditional math equations
\usepackage{graphicx} % This package is used for inserting and manipulating on images
\usepackage{titlesec} % For section, subsection and subsubsection and so on.
\usepackage{caption}
\usepackage{hyphenat} % Use this package for hyphenation
\newenvironment{Figure}
    {\par\medskip\noindent\minipage{\linewidth}}
    {\endminipage\par\medskip}

% Preamble here
\setlength\columnsep{20pt} % This is the default columnsep for all pages
\setcounter{secnumdepth}{4}

\graphicspath{ {../Diagrams/} {../Diagrams/KeyExpansion/} {../Diagrams/MixColumns/} {../Diagrams/ShiftRows/} {../Diagrams/SubBytes/} {../Diagrams/temporary/} {../Diagrams/InvMixColumns/} {../Diagrams/InvShiftRows/} {../Diagrams/InvSubBytes/}}

% Document begins here
\begin{document}

    %%%%%%%%%
    % TITLE %
    %%%%%%%%%
    \title{\centering{IMPLEMENTING AES-256 ON FPGA}}
    \author{}
    \maketitle % Call this command to make title

    \begin{center}
        Ho Hai Cong Thuan\\
        Student, Computer Engineering, University of Information Technology, HCMC, Vietnam\\
        hohaicongthuan@gmail.com
    \end{center}
    \begin{multicols}{2}
        
        %%%%%%%%%%%%
        % ABSTRACT %
        %%%%%%%%%%%%
        \textbf{\textit{Abstract\textemdash}In modern days, the amount of data grow exponentially, including classified and sensitive data that need to be kept secured. For this reason, many cryptographic techniques have been invented for this purpose. AES is one of them. It provides fast and secure data encryption which are the reasons this algorithm is chosen for this project.}

        \textbf{The goal of this project is to implement a fully functional AES encryption and decryption system using 256-bit keys on FPGA.}
        
        \bigskip

        \textbf{\textit{Keywords\textemdash}AES-256; cryptography; data security; FPGA; encryption; decryption.}

        %%%%%%%%%%%
        % CONTENT %
        %%%%%%%%%%%
        \section{INTRODUCTION}
            \textit{The Advanced Encryption Standard (AES)}, also known as \textit{Rijndael} is a specification for encrypting electronic data first introduced by the \textit{U.S. National Institute of Standards and Technology (NIST)} in 2001 \cite{AES}. It provides a fast and secure way to encrypt data and uses symmetric keys encryption which means both the encryption and decryption processes using the same key. The key length for AES could be 128, 192 and 256 bits. This paper concentrates on AES using 256-bit keys which will be referred to as AES-256 for the rest of this paper.
            
            \subsection{Concepts used in AES-256}
                % \begingroup
                    % \setlength{\tabcolsep}{10pt} % Default value: 6pt
                    % \renewcommand{\arraystretch}{1.5} % Default value: 1
                    \noindent
			\begin{center}
                    \begin{tabular}{m{2cm} m{5.5cm}}
                        \textbf{\textit{Key expansion}} & Routine used to generate a set of Round Keys from the Cipher Key.\\
                        \hline
                        \textbf{\textit{State}} & Intermediate Cipher result that can be pictured as a rectangular array of bytes, having four rows and \textbf{\textit{Nb}} columns.\\
                        \hline
                        \textbf{\textit{S-box}} & Substitution table used in byte substitution transformation and in the Key Expansion routine to perform a one-for-one replacement of a byte value.\\
                        \hline
                        \textbf{\textit{Word}} & A group of 32 bits that is treated either as a single entity or as an array of 4 bytes.\\
                    \end{tabular}
			\end{center}
                % \endgroup
            
            \subsection{Abbreviations and Symbols used in AES-256}
                % \begingroup
                    \setlength{\tabcolsep}{5pt} % Default value: 6pt
                    \renewcommand{\arraystretch}{1.5} % Default value: 1
                    \noindent
                        \begin{center}
				\begin{tabular}{m{1cm} m{7cm}}
                            \textbf{\textit{Nb}} & Number of columns (32-bit words) comprising the State. For this
                            standard, \textbf{\textit{Nb}} = 4.\\
                            \hline
                            \textbf{\textit{Nk}} & Number of 32-bit words comprising the Cipher Key. For this standard, \textbf{\textit{Nk}} = 8.\\
                            \hline
                            \textbf{\textit{Nr}} & Number of rounds, which is a function of \textbf{\textit{Nk}} and \textbf{\textit{Nb}} (which is
                            fixed). For this standard, \textbf{\textit{Nr}} = 14.\\
                            \hline
                            XOR & Exclusive-OR operation\\
                            \hline
                            $\oplus$ & Exclusive-OR operation\\
                            \hline
                            $\otimes$ & Multiplication of two polynomials (each with degree $<$ 4) modulo $x^{4}+1$\\
                            \hline
                            $\bullet$ & Finite field multiplication\\
                        \end{tabular}
				\end{center}
                % \endgroup

        \section{AES-256}
            \subsection{Key Expansion}
                The Key Expansion routine in AES-256 takes a 256-bit cipher key and generate a set of $Nb(Nr+1)$ (which is 60) words. These words are smaller parts that make up round keys, each round key has four words. These round keys involve in the \textit{Add Round Key} in the encryption and decryption process.

                There are 3 functions that participate in the key scheduling process:

                % \begingroup
                    \setlength{\tabcolsep}{5pt} % Default value: 6pt
                    \renewcommand{\arraystretch}{1.5} % Default value: 1
                    \noindent
                        \begin{tabular}{m{2cm} m{6cm}}
                            \textbf{\textit{RotWord}} & Takes a four-byte word $[a_{0},a_{1},a_{2},a_{3}]$ and performs rotation one byte to the left and returns $[a_{1},a_{2},a_{3},a_{0}]$.\\
                            \hline
                            \textbf{\textit{SubWord}} & Takes a four-byte word and substitute each byte with the corresponding byte in the S-box.\\
                            \hline
                            \textbf{\textit{Rcon}} & The round constants, which is given in the form $[rc_{i},00_{16},00_{16},00_{16}]$ with $i$ starts from 1. $rc_{i}$ is defined as in (1)\\
                        \end{tabular}

                \begin{equation}
                    rc_{i}=
                    \begin{cases}
                        1 & \text{if } i=1\\
                        2 \cdot  rc_{i-1} & \text{if } i>1 \text{ and } rc_{i-1}<80_{16}\\
                        \left(2 \cdot  rc_{i-1}\right)\oplus 11\text{B}_{16} & \text{if } i>1 \text{ and } rc_{i-1} \ge 80_{16}
                    \end{cases}
                \end{equation}
                % \endgroup

            % \subsubsection{Algorithm}
                In AES-256, the first two round keys (first 8 words) are filled with the cipher key. For the rest, $w[i]$ word is generated using $w[i-1]$ word.

                Loop through the following steps until we have generated $Nb(Nr+1)$ words.

                If $i$ is divisible by \textbf{\textit{Nk}}, $w[i-1]$ is rotated by the function \textbf{\textit{RotWord}} and then substituted by the function \textbf{\textit{SubWord}}. The final result is \textbf{\textit{XOR}}-ed with \textbf{\textit{Rcon[i/Nk]}} and assigned to $w[i]$. Otherwise, if $i$ dividing by \textbf{\textit{Nk}} results in $4$ as the remainder, only \textbf{\textit{SubWord}} is performed on $w[i-1]$.

                $w[i]$ will then be \textbf{\textit{XOR}}-ed with $w[i-Nk]$ and the result is assigned back to itself. $i$ is incremented by 1.

                After finishing the algorithm, a set of $Nb(Nr+1)$ words is generated. Round Keys are created by grouping four words each sequentially. At this point, we have one round key for the initial round and 14 round keys for 14 rounds during the encryption or decryption processes, with a total of 15 round keys. Details about the algorithm as well as pseudo-code for it can be found at \cite{AES} and \cite{sam-key-expansion}.

            \subsection{AES-256 Encryption}

	The AES-256 Encryption process comprises of fourteen rounds plus the initial round. In the initial round, the input data will be added with the initial round key. In the next thirteen rounds, all the  \textit{SubBytes}, \textit{ShiftRows}, \textit{MixColumns}, and \textit{AddRoundKey} transformations will be performed on the \textit{State}, respectively. In the last round, only \textit{SubBytes}, \textit{ShiftRows}, and \textit{AddRoundKey} are performed.

            \subsubsection{Bytes Substitution}

            Bytes Substitution transformation is denoted by \textit{SubBytes} function. This independently replaces all the bytes in the \textit{State} with the corresponding bytes using a \textit{substituion box} (or \textit{S-Box}), which is shown in the figure \ref{fig:SBox}.

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{S-Box.png}
                \captionof{figure}{Substitution Box (S-Box) used in \textit{SubBytes} transformation.}
                \label{fig:SBox}
            \end{Figure}

            The higher 4 bits determine the coordinate of the row and the lower 4 bits determine the coordinate of the column. For example, the byte \textbf{5A}, we have $x=5$ \& $y=A$, these values point to the new value in the table, which is \textbf{BE}. So \textbf{5A} will be substituted by \textbf{BE}. Details about transformations to create S-Box can be found at \cite{AES} and \cite{sam-s-box}.

            \subsubsection{Shift Rows}
            \label{sec:shift-rows-intro}

            In the \textit{ShiftRows} transformation, the last three row of the \textit{State} will be rotated to the left with different byte offsets.

            The first row of the \textit{State} is unaffected. The second row will be rotated to the left by one byte, two bytes for the third row, and three bytes for the fourth row. Therefore,

            \begin{equation}
                \begin{bmatrix}
                    a_{0} & a_{4} & a_{8} & a_{12}\\
                    a_{1} & a_{5} & a_{9} & a_{13}\\
                    a_{2} & a_{6} & a_{10} & a_{14}\\
                    a_{3} & a_{7} & a_{11} & a_{15}
                \end{bmatrix}
                \label{equ:shift-rows-example}
            \end{equation}

            will become

            \begin{equation}
                \begin{bmatrix}
                    a_{0} & a_{4} & a_{8} & a_{12}\\
                    a_{5} & a_{9} & a_{13} & a_{1}\\
                    a_{10} & a_{14} & a_{2} & a_{6}\\
                    a_{15} & a_{3} & a_{7} & a_{11}
                \end{bmatrix}
            \end{equation}

            after \textit{ShiftRows} transformation.

            \subsubsection{Mix Columns}
            \label{sec:mixcolumns}

            \textit{MixColumns} transformation operates column-by-column on the \textit{State}. Each column is multiplied with a fixed matrix which results in a new column with new values.

            The fixed matrix used in \textit{MixColumns} is shown below:

            \begin{equation}
            \begin{bmatrix}
                02 & 03 & 01 & 01\\
                01 & 02 & 03 & 01\\
                01 & 01 & 02 & 03\\
                03 & 01 & 01 & 02
            \end{bmatrix}
            \label{equ:mixcolumns-matrix}
        \end{equation}

        The multiplication operation performed in this \textit{MixColumns} transformation is not ordinary integer multiplication but multiplication in \textit{GF($2^{8}$)}, which can be performed at byte level as left shift operation followed by the conditional \textit{XOR} operation with the number \textbf{1B} in hexadecimal. More examples and in-depth explanation about this transformation can be found at \cite{AES}, \cite{sam-mix-columns}, and \cite{understand_mixcol}.

            \subsection{AES-256 Decryption}

	The AES-256 Decryption process is the inverse of the AES-256 Encryption process. Basically, it is the same as the encryption process but in reverse. Round keys used in the decryption process are also in reverse order. However, the \textit{SubBytes}, \textit{ShiftRows}, and \textit{MixColumns} transformations are replaced with \textit{InvSubBytes}, \textit{InvShiftRows}, and \textit{InvMixColumns}, respectively. Details of those transformations are discussed in the following sub-sections.

            \subsubsection{Inverse Bytes Substitution}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{Inv S-box.png}
                \captionof{figure}{Inverse S-Box}
                \label{fig:inv-s-box}
            \end{Figure}

	\noindent
            \begin{figure*}[t]
                \centering
                \includegraphics[width=0.8\linewidth]{AES-256.png}
                \captionof{figure}{Top-level design of AES-256.}
                \label{fig:aes-256-top-level-design}
            \end{figure*}

            In the \textit{Inverse Bytes Substitution} transformation, which is denoted as \textit{InvSubBytes}, all bytes from the \textit{State} will be replaced by the corresponding bytes from the inverse S-Box, which is shown in figure \ref{fig:inv-s-box}.

            \subsubsection{Inverse Shift Rows}

            \textit{Inverse Shift Rows} denoted as \textit{InvShiftRows} is the inverse of \textit{ShiftRows} transformation. Each row from the \textit{State} is rotated with different offsets to the right instead of left. According to that, the first row is untouched, the second row is rotated one byte to the right, rotated two bytes to the right for the third row, and three bytes for the fourth row. Suppose (\ref{equ:shift-rows-example}) as the example input, after \textit{InvShiftRows} transformation, the input will become

            \begin{equation}
                \begin{bmatrix}
                    a_{0} & a_{4} & a_{8} & a_{12}\\
                    a_{13} & a_{1} & a_{5} & a_{9}\\
                    a_{10} & a_{14} & a_{2} & a_{6}\\
                    a_{7} & a_{11} & a_{15} & a_{3}
                \end{bmatrix}
            \end{equation}

            \subsubsection{Inverse Mix Columns}
	\label{sec:invmixcolumns}

            \textit{Inverse Mix Columns} denoted as \textit{InvMixColumns} is the inverse of \textit{MixColumns} transformation. Each column from the \textit{State} is multiplied with the inverse matrix of the matrix (\ref{equ:mixcolumns-matrix}), which is shown in (\ref{equ:inv-mixcolumns-matrix}), using the multiplication in \textit{$GF(2^{8})$}. Note that all numbers in the matrix are written in hexadecimal.

            \begin{equation}
                \begin{bmatrix}
                    0e & 0b & 0d & 09\\
                    09 & 0e & 0b & 0d\\
                    0d & 09 & 0e & 0b\\
                    0b & 0d & 09 & 0e
                \end{bmatrix}
                \label{equ:inv-mixcolumns-matrix}
            \end{equation}

            \subsection{Add Round Keys}

            Round keys generated from \textit{Key Expansion} routine will be used in this transformation. It takes two 128-bit input data and output 128-bit data. Round keys are added to the \textit{State} by bitwise \textit{XOR} operations with the corresponding bytes. 

        \section{IMPLEMENTATION}

	The top-level design for AES-256, including encryption and decryption, is shown in figure \ref{fig:aes-256-top-level-design}. The implementation of smaller modules is discussed in the following sub-sections.

          \subsection{Key Expansion}

	\noindent
            \begin{figure*}[t]
                \centering
                \includegraphics[width=\linewidth]{KeyExpansion.png}
                \captionof{figure}{Diagram of Key Expansion.}
                \label{fig:KeyExpansion}
            \end{figure*}

            The design of the Key Expansion routine is shown in figure \ref{fig:KeyExpansion}. As in the design, the total of 15 round keys, including the round key for the initial round, will be created first before they could involve in the \textbf{\textit{Add Round Key}} function in the encryption and decryption process.
            
            This circuit will generate words that make up the Round Key one-by-one and store them in the \textit{Register File}. The \textit{Register File} has a total amount of 64 registers but only 60 of them are used because we only need to generate 60 words. The module \textit{Rcon} and \textit{SubWord} are implemented in the form of look-up tables (LUTs).

            In order for the circuit to work, the \textit{reset} signal must be pulled low (the \textit{reset} signal is active low) and then the \textit{enable} signal is pulled high. The cipher key can be passed through \textit{Input Data}. After reset, the counter's value will be set to zero and increased by 1 after each clock cycle. In the meantime, the inputted cipher key will be broken up into words, which are 32 bits each, and stored in eight registers from $w_{0}$ to $w_{7}$.
            
            In the next eight clock cycles, each of the words will be saved into the \textit{Register File} sequentially from the address 1 to 8. After that, to generate the $i^{th}$ word, $(i-1)^{th}$ and $(i-Nk)^{th}$ words are required, which can be accessed through Register File's Out\_A \& Out\_B ports respectively, with the addresses are selected by $i-1$ \& $i-8$ blocks in the circuit.

            Depend on which word is generating, \textit{RotWord}, \textit{SubWord} can all be performed or just \textit{SubWord} is performed or neither of those. This is controlled by signals from \textit{mod 9 = 4} \& \textit{mod 9 = 0} blocks. Basically, the \textit{mod 9 = 4} block checks if a input number dividing by 9 has 4 as the remainder. If it is, the output will be pulled high and pulled low if it is not. Same thing with the \textit{mod 9 = 0} block but with 0 as the remainder. The design of \textit{mod 9 = 0} \& \textit{mod 9 = 4} are shown in figure \ref{fig:mod9eq0} and figure \ref{fig:mod9eq4}, respectively.
            
            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{Mod9Eq0.png}
                \captionof{figure}{Circuit of \textit{mod 9 = 0} block}
                \label{fig:mod9eq0}
            \end{Figure}

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{Mod9Eq4.png}
                \captionof{figure}{Circuit of \textit{mod 9 = 4} block}
                \label{fig:mod9eq4}
            \end{Figure}

            All the words will have been generated after sixty-one clock cycles. The counter will shut itself and the \textit{ready} signal is set indicating all round keys have been generated. After done generating and the \textit{ready} signal is set, round keys can be accessed by inputting the appropriate address through \textit{Key Address} input, which has a value range from 0 to 14.
            
            \subsection{AES-256 Encryption}

	\noindent
            \begin{figure*}[t]
                \centering
                \includegraphics[width=\linewidth]{AES_encrypt.png}
                \captionof{figure}{Diagram of AES Encryption Circuit.}
                \label{fig:AES_encrypt}
            \end{figure*}

	Figure \ref{fig:AES_encrypt} shows the design of AES Encryption circuit. This circuit takes 128-bit data in and a set of round keys to perform AES encryption on the inputted data.

	A reset signal must be inputted in order for the circuit to work properly. A counter will keep track of which round and round key the encryption process is currently at. In the first clock cycle, inputted data will be stored in a register and added with the first round key and saved in another register that acts as the \textit{State}, completing the initial round. In the next thirteen clock cycles, the circuit performs thirteen rounds comprising \textit{SubBytes}, \textit{ShiftRows}, \textit{MixColumns}, and \textit{AddRoundKey} transformations in each round on the \textit{State}. In the last round, the \textit{MixColumns} transformation is opted out. The encryption process will be completed after fifteen clock cycles and the \textit{done} signal will be pulled high.
	
	Details on smaller circuits in this AES Encryption circuit like \textit{SubBytes}, \textit{ShiftRows}, \textit{MixColumns}, etc. are represented in the following sub-sections.

            \subsubsection{Bytes Substitution}

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{SubBytes.png}
                \captionof{figure}{SubBytes circuit diagram.}
                \label{fig:subbytes}
            \end{Figure}

            The design for \textit{SubBytes} block is shown in figure \ref{fig:subbytes}. The \textit{SBox} used in this circuit is implemented as LUT and is the same as \textit{SBox} from figure \ref{fig:SBox} and \textit{SubWord} in \textit{Key Expansion} routine.

            This circuit takes 128-bit data and splits it into words and then into individual bytes. Each byte will be fed into \textit{SBox} and the corresponding byte will be outputted. The outputted bytes will then be combined into words and eventually into 128-bit output data.

            \subsubsection{Shift Rows}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{ShiftRows.png}
                \captionof{figure}{ShiftRows circuit diagram.}
                \label{fig:shiftrows}
            \end{Figure}

            The circuit diagram for \textit{ShiftRows} is shown in figure \ref{fig:shiftrows}. This circuit takes 128-bit data in, performs shifting and outputs 128-bit data.

            The inputted data will first be split into 32-bit words, note that each word corresponds to a column in the \textit{State}. The first row is formed by taking the first byte in each word, and the second byte in each word for the second row and so on for the third and fourth rows. After dividing the input into rows, the shifting operation is done by wiring each row with the corresponding offsets which discussed in section \ref{sec:shift-rows-intro}.

            Finally, all the rows will be split and combined into correct columns and rows format of the \textit{State}.

            \subsubsection{Mix Columns}

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{MixColumns.png}
                \captionof{figure}{MixColumns circuit diagram.}
                \label{fig:mixcolumns}
            \end{Figure}

            In figure \ref{fig:mixcolumns} is the circuit design for \textit{MixColumns} transformation. The 128-bit data input fed into the circuit is divided into four words. Each word is fed into \textit{First\_Row\_Mul}, \textit{Second\_Row\_Mul}, \textit{Third\_Row\_Mul}, and \textit{Fourth\_Row\_Mul} blocks, which is basically multiplying that word using the multiplication in \textit{GF($2^{8}$)} with first, second, third, and fourth rows of the matrix (\ref{equ:mixcolumns-matrix}) from section \ref{sec:mixcolumns}. Each of the four blocks will output a new byte after the multiplication. Four bytes will be combined into a word. And the 128-bit output is formed by combining four words.

	\noindent
            \begin{figure*}[t]
                \centering
                \includegraphics[width=\linewidth]{AES_decrypt.png}
                \captionof{figure}{Diagram of AES Decryption Circuit.}
                \label{fig:AES_decrypt}
            \end{figure*}

            The design of \textit{First\_Row\_Mul}, \textit{Second\_Row\_Mul}, \textit{Third\_Row\_Mul}, and \textit{Fourth\_Row\_Mul} blocks is shown in figure \ref{fig:first-row-mul}, \ref{fig:second-row-mul}, \ref{fig:third-row-mul}, and \ref{fig:fourth-row-mul}, respectively. Note that all the addition operations (the plus symbol) in these circuits are all \textit{XOR} operations.

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{First_Row_Mul.png}
                \captionof{figure}{First\_Row\_Mul.}
                \label{fig:first-row-mul}
            \end{Figure}

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{Second_Row_Mul.png}
                \captionof{figure}{Second\_Row\_Mul.}
                \label{fig:second-row-mul}
            \end{Figure}

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{Third_Row_Mul.png}
                \captionof{figure}{Third\_Row\_Mul.}
                \label{fig:third-row-mul}
            \end{Figure}

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{Fourth_Row_Mul.png}
                \captionof{figure}{Fourth\_Row\_Mul.}
                \label{fig:fourth-row-mul}
            \end{Figure}

            The implementation of the multiplication by 2 in \textit{GF($2^{8}$)}, which is denoted as \textit{gmul\_2}, is shown in figure \ref{fig:gmul-2}. This multiplication operation is performed at byte level as shift operation one bit to the left followed by a conditional \textit{XOR} operation with the number \textit{1B} in hexadecimal.

            \noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{gmul_2.png}
                \captionof{figure}{gmul\_2.}
                \label{fig:gmul-2}
            \end{Figure}

            \subsection{AES-256 Decryption}

	Figure \ref{fig:AES_decrypt} shows the circuit diagram for the AES-256 decryption unit. Equivalently to the AES-256 encryption unit, the decryption unit also has a counter to keep track of which round and round key the process is currently at.

	After a reset signal, in the initial round, the data will be added with the last round key in the series of round keys generated by \textit{Key Expansion} routine and the result is stored in another register acting as the \textit{State}. After that, the circuit will perform 14 rounds on the \textit{State} through \textit{InvShiftRows}, \textit{InvSubBytes}, \textit{AddRoundKey}, and \textit{InvMixColumns} transformations, in the order mentioned. In the final round, the \textit{InvMixColumns} transformation is not performed. Note that the order of round keys used in the decryption process is in reverse order prior to the encryption process. The final result and the \textit{done} signal will be outputted after 15 clock cycles.

	Details about \textit{InvSubBytes}, \textit{InvShiftRows}, and \textit{InvMixColumns} transformation are discussed in the following sub-sections.

            \subsubsection{Inverse Byte Substitution}

	Both circuit design for \textit{InvSubBytes} and \textit{SubBytes} are similar. The only difference is \textit{InvSBox} is used instead of \textit{SBox} in \textit{InvSubBytes} transformation. Note that both \textit{SBox} and \textit{InvSBox} are implemented as LUTs.

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvSubBytes.png}
                \captionof{figure}{InvSubBytes circuit diagram.}
                \label{fig:invsubbytes}
            \end{Figure}

            \subsubsection{Inverse Shift Rows}

             The circuit design for \textit{InvShiftRows} transformation is similar to the design of \textit{ShiftRows} transformation shown in figure \ref{fig:shiftrows}. However, the wiring is different in the second row and the fourth row. Details can be seen in figure \ref{fig:invshiftrows}.

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvShiftRows.png}
                \captionof{figure}{InvShiftRows circuit diagram.}
                \label{fig:invshiftrows}
            \end{Figure}

            \subsubsection{Inverse Mix Columns}

            The circuit diagram for \textit{InvMixColumns} transformation, which is shown in figure \ref{fig:invmixcolumns}, is a bit more sophisticated than the one for \textit{MixColumns} transformation, yet the top-level designs are still identical.

	\textit{Inv\_First\_Row\_Mul}, \textit{Inv\_Second\_Row\_Mul}, \textit{Inv\_Third\_Row\_Mul}, and \textit{Inv\_Fourth\_Row\_Mul} multiply a column (or a word) from the \textit{State} with the first, second, third, and fourth row of the matrix (\ref{equ:inv-mixcolumns-matrix}) mentioned in section \ref{sec:invmixcolumns}, respectively, using multiplication operation in \textit{GF($2^{8}$)}. The circuit diagrams of those blocks can be seen in figure \ref{fig:invfirstrowmul}, \ref{fig:invsecondrowmul}, \ref{fig:invthirdrowmul}, \ref{fig:invfourthrowmul}, respectively.

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-Inv_First_Row_Mul.png}
                \captionof{figure}{Inv\_First\_Row\_Mul circuit diagram.}
                \label{fig:invfirstrowmul}
            \end{Figure}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-Inv_Second_Row_Mul.png}
                \captionof{figure}{Inv\_Second\_Row\_Mul circuit diagram.}
                \label{fig:invsecondrowmul}
            \end{Figure}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-Inv_Third_Row_Mul.png}
                \captionof{figure}{Inv\_Third\_Row\_Mul circuit diagram.}
                \label{fig:invthirdrowmul}
            \end{Figure}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-Inv_Fourth_Row_Mul.png}
                \captionof{figure}{Inv\_Fourth\_Row\_Mul circuit diagram.}
                \label{fig:invfourthrowmul}
            \end{Figure}

	\textit{gmul\_9}, \textit{gmul\_e}, \textit{gmul\_b}, and \textit{gmul\_d} multiply an input number with 9, e, b, and d, respectively, using multiplication in \textit{GF($2^{8}$)}. Note that all numbers in this section are in hexadecimal. Multiplying a number $x$ with the number 9 in \textit{GF($2^{8}$)} can be broken down as 

\begin{equation}
\begin{aligned}
	x \bullet 9 &= \left(x \bullet 8\right) \oplus x \\
	&= \left(x \bullet 4 \bullet 2\right) \oplus x \\
	&= \left(x \bullet 2 \bullet 2 \bullet 2\right) \oplus x
\end{aligned}
\end{equation}

	Since we have created the multiplier by 2 in \textit{GF($2^{8}$)}, denoted as \textit{gmul\_2} and shown in figure \ref{fig:gmul-2}, so we can use that to create smaller components that make up the \textit{gmul\_9} as shown in figure \ref{fig:gmul-4}, \ref{fig:gmul-8}, and \ref{fig:gmul-9}.

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-gmul_4.png}
                \captionof{figure}{gmul\_4 circuit diagram.}
                \label{fig:gmul-4}
            \end{Figure}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-gmul_8.png}
                \captionof{figure}{gmul\_8 circuit diagram.}
                \label{fig:gmul-8}
            \end{Figure}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-gmul_9.png}
                \captionof{figure}{gmul\_9 circuit diagram.}
                \label{fig:gmul-9}
            \end{Figure}

	Similarly, multiplying a number $x$ with the number b can be broken down as

\begin{equation}
\begin{aligned}
	x \bullet b & = (x \bullet 9) \oplus (x \bullet 2) \\
	& = (x \bullet 8) \oplus x \oplus (x \bullet 2)
\end{aligned}
\end{equation}

	Therefore, we can use the previously made \textit{gmul\_9} to make \textit{gmul\_b}.

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-gmul_b.png}
                \captionof{figure}{gmul\_b circuit diagram.}
                \label{fig:gmul-b}
            \end{Figure}

	Equivalently, multiplying by d and e can be rewritten as in (\ref{equ:gmul-d}) and (\ref{equ:gmul-e}), in the order mentioned.

\begin{equation}
\label{equ:gmul-d}
\begin{aligned}
	x \bullet d & = (x \bullet 9) \oplus (x \bullet 4)
\end{aligned}
\end{equation}

\begin{equation}
\label{equ:gmul-e}
\begin{aligned}
	x \bullet e & = (x \bullet 8) \oplus (x \bullet 4) \oplus (x \bullet 2)
\end{aligned}
\end{equation}

	As a result, we can totally use previously made circuits to make \textit{gmul\_d} and \textit{gmul\_e}.

	Note that all the plus signs in all the diagrams in this section represent the \textit{XOR} operation.

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-gmul_d.png}
                \captionof{figure}{gmul\_d circuit diagram.}
                \label{fig:gmul-d}
            \end{Figure}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-gmul_e.png}
                \captionof{figure}{gmul\_e circuit diagram.}
                \label{fig:gmul-e}
            \end{Figure}

	\noindent
            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{InvMixColumns-top.png}
                \captionof{figure}{InvMixColumns circuit diagram.}
                \label{fig:invmixcolumns}
            \end{Figure}

            \subsection{Add Round Keys}

            \textit{AddRoundKeys} can simply be performed by the \textit{XOR} operation with the \textit{State} and a round key, which both have the length of 128 bits. The output is 128-bit.

        \section{RESULTS}

        \subsection{Key Expansion}

        Figure \ref{fig:keyexpansion-sim} shows simulation waveform result using \textit{ModelSim}. As can be seen in the figure, after 61 clock cycles since the last \textit{reset} signal, the \textit{ready} signal is set indicating round keys have been generated. Therefore, they can be retrieved correctly, which is the part circled in the figure.

            \begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{KeyExpansion-GetRoundKeysStage-edited.png}
                \captionof{figure}{Key Expansion simulation result in \textit{ModelSim}.}
                \label{fig:keyexpansion-sim}
            \end{Figure}

        The circuit is tested with different keys from the example section in \cite{AES} and the web-based tool \textit{AES Step-by-Step} \cite{aes-step-by-step}. The results produced by the circuit are the same as the expected results in each test case.

	The design is synthesised and compiled on Quartus II 64-Bit for Cyclone III EP3C40F780C6 device. The result is shown in table \ref{tab:keyexpansion}.

	\noindent
	\begin{center}
		\captionof{table}{Synthesis \& Compilation results for Key Expansion.}
		\label{tab:keyexpansion}
                    \begin{tabular}{| m{5.5cm} | m{3cm} |}
		\hline   
		\textbf{Total logic elements} & 4 942/39 600 (12\%)\\
                        \hline
                        \textbf{Total combinational functions} & 4 684/39 600 (12\%)\\
                        \hline
                        \textbf{Dedicated logic registers} & 2 310/39 600 (6\%)\\
                        \hline
				\textbf{Fmax} & 26.15 MHz\\
				\hline
                    \end{tabular}
	\end{center}

        \subsection{AES-256}

	Both encryption and decryption units have been tested and run simulation on \textit{ModelSim}. The results waveform are shown in figure \ref{fig:aes-256-en-sim} for encryption unit and figure \ref{fig:aes-256-de-sim} for decryption unit.

	\begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{aes-256-encryption-waveform-edited.png}
                \captionof{figure}{AES-256 encryption simulation result in \textit{ModelSim}.}
                \label{fig:aes-256-en-sim}
            \end{Figure}

	\begin{Figure}
                \centering
                \includegraphics[width=\linewidth]{aes-256-decryption-waveform-edited.png}
                \captionof{figure}{AES-256 decryption simulation result in \textit{ModelSim}.}
                \label{fig:aes-256-de-sim}
            \end{Figure}

	As can be seen in the two figures above, the done signal (the last line in both figures) is set when the circuit has done the encryption/decryption process indicating the current result is the final result. There are a couple of clock cycles needed for \textit{Key Expansion} routine to generate round keys before the encryption/decryption process can actually start. That is the reason why it takes a fair amount of clock cycles to spit out the final output in the two figures. It needs a total of 76 clock cycles for the circuit to yield the final result, 61 clock cycles of which are for the \textit{Key Expansion} unit to generate round keys and the other 15 clock cycles are for the encryption/decryption process.

	The design is synthesised and compiled on Quartus II 64-Bit for Cyclone III EP3C40F780C6 device. The result is shown in table \ref{tab:aes-256}.

        \noindent
	\begin{center}
		\captionof{table}{Synthesis \& Compilation results for AES-256.}
		\label{tab:aes-256}
                    \begin{tabular}{| m{5.5cm} | m{3cm} |}
		\hline   
		\textbf{Total logic elements} & 13 776/39 600 (35\%)\\
                        \hline
                        \textbf{Total combinational functions} & 12 687/39 600 (32\%)\\
                        \hline
                        \textbf{Dedicated logic registers} & 2 698/39 600 (7\%)\\
                        \hline
				\textbf{Fmax} & 24.59 MHz\\
				\hline
                    \end{tabular}
	\end{center}

	The timing analysis results can be seen in table \ref{tab:timing-results}.

	\noindent
	\begin{center}
		\captionof{table}{Timing Analysis results for AES-256.}
		\label{tab:timing-results}
                    \begin{tabular}{| m{4cm} | m{2cm} | m{2cm} |}
		\hline   
		 & \textbf{Fmax} & 24.59 MHz \\
		 \textbf{Slow 1200mV 85C Model}& \textbf{Setup Slack} & 4.670 \\
									    & \textbf{Hold Slack} & 0.355 \\
									    & \textbf{Data-rate} & 41.41 Mb/s \\
                        \hline
		 & \textbf{Fmax} & 27.23 MHz \\
		 \textbf{Slow 1200mV 85C Model}& \textbf{Setup Slack} & 6.635 \\
									    & \textbf{Hold Slack} & 0.309 \\
									    & \textbf{Data-rate} & 45.86 Mb/s \\
				\hline
                    \end{tabular}
	\end{center}

        \section{CONCLUSION}

        This paper has represented the design of AES-256 that can do basic functionalities like encryption and decryption. Nevertheless, this design has not been well-optimised and thus manifested some limitations as well as other things that could be improved in future research.

	The goal of this project is to make a fully functional AES-256 encryption and decryption system on FPGA. For this reason, optimising for speed and resources have not yet been taken into consideration, so the performance might be poor. Another downside of this design that it has to be reset for each time it performs encryption or decryption which leads to the re-calculation of round keys, even when the same cipher key is used for encryption and decryption, and thus wasting time as well as slowing the encryption/decryption speed down.

        %%%%%%%%%%%%%%%%%%%%%%%%%%
        % REFERENCE SECTION HERE %
        %%%%%%%%%%%%%%%%%%%%%%%%%%
        \begin{thebibliography}{3}
            \bibitem{AES}
            Federal Information Processing Standard (FIPS) 197.
            \textit{Advanced Encryption Standard (AES)}
            26 November 2001.

            \bibitem{sam-key-expansion}
            Sam Trenholme.
            \textit{Rijndael's key schedule.\\https://samiam.org/key-schedule.html}.

            \bibitem{sam-mix-columns}
            Sam Trenholme.
            \textit{Rijndael's mix column stage.\\https://samiam.org/mix-column.html}.

            \bibitem{sam-s-box}
            Sam Trenholme.
            \textit{Rijndael's S-Box.\\https://samiam.org/s-box.html}.

            \bibitem{understand_mixcol}
            Kit Choy Xintong.
            \textit{Understanding AES Mix-Columns Transformation Calculation}.

		\bibitem{aes-step-by-step}
            AES Step-by-Step.
            \textit{https://www.cryptool.org/en/cto/aes-step-by-step}.
        \end{thebibliography}

    \end{multicols}

\end{document}
